import * as variables from "/home/kdog3682/2023/variables.js"
import {traverse, simpleTraverse, Traversal, inAndOut} from "/home/kdog3682/2024-javascript/js-toolkit/traverse.js"
/* deno-fmt-ignore */ import { splitInHalf,fooga, pop4, map4, AbstractVisitor, shellEscape, getkv, toggleBooleanState, numbered, noidea, assertObjectValue, assertValue, getClasses, exit, choose, getFileName, testEqual, pause, getBindingValueString, templater2, smartDedent5, pop3, moduleExports, joinPath, expandPath, isDecimal, hasPercentage, ass, parsePercentage, Matrix, isInteger, isEquation, isObjectObject, getExtraIndent, shellUnescape, assertEqual, asyncToggle, touched, chosen, lastOf, firstOf, isBlockEnter, group3, loremIpsum, exportString, deepToggle, maybeNewlineIndent, onAndOff, flattenModule, isModule, isNativeHtmlTag, partitionByValues, strcall, getLongest2, must, mconfig, unreachable, notify, storager, joiner, removeVeryStartingComments, ireplace, removeCommentsInPlace, editf, getLineTokens, IndexedStore, abstractError, bool, xassert, getSetLines, inMiddle, replaceLast, ensureExtension, multipleReplacer, getGradeLevel, constructEdit, getYear, Modulus, wrapClassMethods, proseReplacer, parseComments, parseFunctionDictComments, todo, dictAssertion, boundModularIncrement, construct, reduceToString2, pageTurner, assignCumulative, defaultMergeStrategy, dictSetter3, toArguments, reTemplate, parseFrontmatter, typeAssertion, defineGetter, assignAllowed, simpleRecursiveWalk, simpleArgument, exprTemplater, stringifyIfNotPrimitive, panic, stringerf, wrapFunction, regexTemplater, iso8601, strftime, walkChildEntries, getFiletype, matchf, isUrl, looksLikeFunction, toArgument2, notNull, CumulativeStorage2, simpleAssign, findAndMatch, infuseObjectArray, regexGetter, splitArg, isJavascriptComment, runTest, everyOther, splitByRange, get_regex, getImports, isJavascriptFile, isValidDateString, WriteObject, equalityf, group2, splitOnce2, dedent4, isLowerCase, looksLikeRegExpString, isRegExpString, getDependencies, camelSplit, toggle3, countf, isLiteralObject, bindMethodsAndState2, call, mget3, looks_like_object_function, create_functions_from_master, toStringArgumentPretty, codeChunks, smart_map, run_tests, hasStartingCallable, mapTemplate, aliaser, fixSelector, htmlTags, removePythonComments, simpleStringBreaker, colonConfig, operations, error, redColon, so2, group, parseSingleLineJson, Items, findDependencies, tryf, find4, localeString, cssComment, colonConfigf, trimArray, parseCallable, bringToLifeTextFix, localBringToLife, getCaller4, getErrorStack, forEach, getBindings, getExports, matchstr, filter4, allEqual, count, isNativeFunction, repeat, eat, getIndentAndText, StopWatch, stringDictSetter, getFunctionInfo, runRef, toLines, hasCallable, getProseWords, tally, paramify, codeSplit, debugConfig, logConfig, blueColon, toStringArgument3, stringCallable, simpleBinding, dashSplit4, appendBelow, appendAbove, removeLineComments, prependIfNecessary, smartDedent4, blueSandwich, walk4, findLineIndex, parseAB, applyTransform, kebabCase, getExcerpt, sortObject, buildFunction, maybeSort, parseFunction, isTypable, frontMatter, dictEntry, insertAfterIndex, State, bindMethods, cpop, tagRE, toggle2, createFunction2, assignIncrementedIndex, ufa, assignArray, regexFromComment, createParsersFromObject, imatch, globalConsoleDebug, bindMethodsAndState, isQuestion, oxfordComma, isUpperCase, getFunctionIdentifier, filter3, match, getMatch, alternatef, reCombine, assertion2, deepEqual, hasDollar, so, deepAssign, Tally, getFunctionNames, throwError, notEqual, tryString, prettyPrintCodeSnippet, prettyPrintErrorStack, iter, quotify, transformerf, assign, defineBinding, jspy, linebreak, stringCall2, reduce3, getClassParameters, assignOnTop2, isIdentifier, ndy, dashSplit3, runFunctionFromRef, equalf, alphabet, stateGetterFromSchema, mreplace, require, topLineComment, isChinese, replacef, ignoref, codeLibrary, splitLines, addArgumentQuotes, getBindings2, addCaret, mget2, getStartingConfig, incrementalEat, strlen, hr, setOnce, unescapeHtml, oxford, breakerf, runTests, map3, dateSplit, transformDict, walk3, toRegExp, tryAgainf, assertNotNull, getArgumentObject, isArgumentObject, typef, requireArg, keyAndValue, assignf, stateGetter3, objectFromArguments2, assignDefaults, transformValue, assign3, assignFresh3, evaluate3, scopedEvaluator, objectFromArguments, enforce, sub, filterObject, extractStartingJsonLikeConfig, unbrackify, newlineIndent2, deleteLine, both, normalizeIndent, getComment, secondComment, isStringRegExp, dashSplit2, clock, warning, errorStringify, alert, labelCase, bottomComment, stringCompose, getAnyIdentifier, chalkf, getNumbers, partitions, has, addUnit, toCallable, unquote, filter2, warn2, join2, caller2, assignOnce, longShort, shortLong, argPop, caller, assignOnTop, toggle, defineWindow, unescapeNewlines, escapeQuotes, unescapeQuotes, escapeNewlines, setAliases, announceCaller, removeStartingComments, smartBind, assignExisting, isObjectWithKey, eatStart, modularIncrementItem, getRegex, runFunction, isObjectLikeArray, itemGetter2, getAllKeys, prefixSlice, hasQuotes, assertion, diff, toggleState, initState, dunder, objectGetter, superTransform, popFilter, testRunner, assert2, insertAtDollar, popEmptyLine, getOptions, mergeSpecs, sortByKeys, map2, strictMessengerAssert, smartSplit, chalk4, typeLog, getFunctionName, Clock, search3, MyError, fuzzyMatch3, debugDisplay, getCaller3, messengerAssert, camelSlice, setPrototype, assignAliases, display, modifyNumber, toDict, setPush, modularIncrementIndex, longstamp, popIndex, toggleOnOff, locWrap, walk2, typeMatch, prettyStringify, getIdentifiers, CustomError, argMatch, brackify2, smartestDedent, modularIncrementNumber, AbstractMethodError, allUnique, Trie, boundarySplit, numberBoundarySplit, nodeLog, getFirst, defineProperty, supermix, partial, timeLog, timestamp, raise, getIdentifier, conditionalPrefix, conditionalSuffix, QueryList, fuzzyMatch2, buildDict, getTextAndCommand, sprawlFactory, getParameters2, pushf, intersection, union, blue, green, sandwich, getLastSpaces, smartDedent3, red, sort, debounce, checkValue, getCodeChunks, logf, boundary, myError, conditional, isStringFunction, toSpaces, objectf, searchAll, difference, singleQuote, itemGetter, slice2, mergeObjects, once, dashSplit, nchalk, coerceToObject, ArrayState, exporter2, indent2, iterator, removeAllComments, countParams, cumulativeSchemaAssign, argKwargSplit, argParse, removeInlineComments, getFrontMatter, hasHtmlSuffix, lazyArray, isThisFunction, escapeHTML, getKwargs2, search2, toStringArgument, createFuzzyMatch, edit2, splice, zip, merge2, argArgsKwargs, fill2, chalk, vueWrap, splitArray, splitArray2, warn, makeRunner2, searchf2, smartDedent2, dedent2, toArray2, stateGetter2, sortByIndex, IndexedCache, argo, curry2, doUntil2, evaluate2, findall2, findIndex2, findItem2, getCaller2, getErrorStack2, isJson, indexGetter2, insert2, pop2, parseError2, remove2, reduce2, testf2, type2, unshift2, waterfall2, xsplit2, Cache, cumulativeAssign, replaceBefore, topComment, isAsyncFunction, mapSort, getFileURI, getQuotes, isClassObject, isInitialized, getFallback, bindingRE, addObjectOrObjectProperty, forDoubles, isCss, log, iterate, backAndForth, round, iteratorWrapper, toJSON, isFromMap, toString, empty, conditionalString, getConfigArg, hasKey, errorWrap, successWrap, check, toPoints, bind, mixinAliases, isPercentage, isBasicType, reducerStrategy, gather, entries, stateGetter, methodCase, vueCase, push2, smarterIndent, lineSplit, Store, isSingleLetter, prepareText, isSymbol, getShortest, slice, KeyError, deepCopy, argsKwargs, isError, isColor, list, objectEditor, matchall, makeFastRunner, announce, hasLetter, filter, reduce, stringCall, capitalizeName, stop, proseCase, lineDitto, mixinSetters, modularIncrement, distinct, definedSort, groupBy, reWrap2, fuzzyMatch, isPlural, Element, parseError, isPrimitiveArray, callableArgsKwargs, waterfall, defineVariable, info, flat2D, splitThePage, handleError, dedent, TypeAssertion, createFunction, pluralize, remove, Group, PageStorage, Storage, UniqueStorage, Watcher, arrayToDict, addProperty, addQuotes, argWrapFactory, assert, abrev, abf, addExtension, assignFresh, antif, atFirst, atSecond, backspace, bindObject, breaker, blockQuote, brackify, bringToLife, comment, countCaptureGroups, capitalizeTitle, classMixin, callableRE, camelToTitle, curry, createVariable, changeExtension, curryStart, curryEnd, capitalize, copy, camelCase, compose, char2n, camelToDash, deepMerge, datestamp, doublef, dictSetter, dictSetter2, dsearch, doUntil, dashCase, doubleQuote, dict, dictGetter, depluralize, dreplace, dictf, endsWithWord, exporter, edit, exists, evaluate, extend, find, flatMap, fill, fixUrl, functionGetter, findall, fixPath, flat, fparse, findIndex, firstLine, ftest, getKwargs, getFirstName, getBindingName, getParameters, getLastWord, getCodeWords, getCodeWords2, getIndent, getExtension, getLast, getLongest, getChunks, getCaller, getStackTrace, getConstructorName, getFirstWord, getWords, getSpaces, hasComma, hasSpaces, hasHtml, hasBracket, hasNewline, hasCaptureGroup, hasEquals, hasValue, hasCamelCase, hasNumber, hackReplace, insert, indexGetter, incrementf, isCallable, isQuote, isEven, isOdd, isLast, isHTML, isNode, interweave, inferLang, isString, isArray, isObject, isDefined, isFunction, isPrimitive, isNumber, isSet, isNestedArray, indent, isNull, isWord, isBoolean, isRegExp, identity, isObjectLiteral, isJsonParsable, isCapitalized, isNewLine, isObjectArray, isStringArray, isClassFunction, joinSpaces, join, keyArrayToObject, lowerCase, linebreakRE, len, lineGetter, lineCount, lastLine, logConsole, makeRunner, mixin, modularf, matchGetter, merge, mget, map, mergeOnTop, mergeToObject, mapFilter, noop, nestPush, no, newlineIndent, n2char, objectWalk, overlap, objectToString, opposite, pipe, parseTopAttrs, pascalCase, partition, parens, push, pop, parseJSON, rigidSort, removeQuotes, rep, removeComments, range, removeExtension, rescape, reverse, reWrap, reduceToString, repeatUntil, swapKey, sayhi, swap, splitMapJoin, splitCamel, smallify, search, stringify, shared, smartDedent, stringBreaker, sleep, split, snakeCase, stringArgument, sorted, splitOnce, searchf, secondLine, titleCase, textOrJson, toNumber, toArgument, toNestedArray, test, type, tail, transformObject, trim, testf, toArray, templater, totalOverlap, upperCase, unique, uncapitalize, unzip, wrap, walk, wrapf, xsplit, yes, zip2} from "/home/kdog3682/2023/utils.js"
export { JavascriptVisitors }

// this visitorSet will 


function brackets(args, wrapper, delimiter = ",") {
    const indentation = 4
    const [a, b] = splitInHalf(wrapper)
    const trailingComma = delimiter
    const top = a + "\n"
    const body = indent(args.join(delimiter + "\n"), indentation)
    const bottom = trailingComma + "\n" + b
    return top + body + bottom
}
function paramString(args, maxLength = 30) {
    // const mapper = ([a, b]) => {
        // if (isDefined(b)) {
            // return `${a} = ${b}`
        // }
        // return a
    // }
    // need "value"

    const mapper = ([a, b]) => {
        if (isDefined(b)) {
            return `${a.value} = ${b.value}`
        }
        return a.value
    }

    const params = args.map(mapper)
    // pause("pausing @ params", params)
    const s = `(${params.join(", ")})`
    if (s.length > maxLength) {
        return brackets(args, "()")
    }
    return s
}

function argString(args, maxLength = 30) {
    const s = `(${args.join(", ")})`
    if (s.length > maxLength) {
        return brackets(args, "()")
    }
    return s
}
function visitChildren(self, ast, env) {
    return self.visitAll(ast, env)
}
function visitFirst(self, ast, env) {
    return self.visit(ast.children[0], env)
}
function sortAst(ast) {
    const ref = {
        ImportDeclaration: 1,
        VariableDeclaration: 10,
        FunctionDeclaration: 100,
        ClassDeclaration: 100,
        ExportDeclaration: 1000,
    }
    const sorter = (ast) => {
        const name = ast.name
        const rank = ref[name]
        return rank
    }
    return sort(ast.children, sorter)
}
function checkEnv(root) {
    const missing = new Set()
    const walker = (env) => {
        for (const item of env.missing) {
            if (root.variables.has(item)) {
                root.touch(item)
            } else {
                missing.add(item)
            }
        }
    }

    traverse(root, walker)
    const touched = root.touched
    const top = root.variables.keys()
    const ignorable = variables.javascriptNativeBindings
    const untouched = difference(top, touched, ignorable)
    return {
        implied: Array.from(missing), 
        untouched,
    }
}
const JavascriptVisitors = {
    Script(ast, env) {
        // const children = sortAst(ast)
        const children = ast.children
        const value = join(visitChildren(this, children, env))
        const check = checkEnv(env)
        console.log("check", check)
        return value
    },
    PrefixExpression(ast, env) {
        throw 'todo'
    },

    PostfixExpression(ast, env) {
        const children = visitChildren(this, ast, env)
        return children.join('')
    },

    ForStatement(ast, env) {
        const children = visitChildren(this, ast, env)
        return children.join(' ')
    },
    ForSpec(ast, env) {
        const children = visitChildren(this, ast, env)
        return `for (${children.join('; ')})`
    },

    ForInSpec(ast, env) {
        const [a, b] = visitChildren(this, ast, env)
        const prefix = ast.children[0].attrs?.constPrefix
            ? 'const' : 'let'
        return `for (${prefix} ${a} in ${b})`
    },
    ForOfSpec(ast, env) {
        const [a, b] = visitChildren(this, ast, env)
        const prefix = ast.children[0].attrs?.constPrefix
            ? 'const' : 'let'
        return `for (${prefix} ${a} of ${b})`
    },
    BooleanLiteral({value}) {
        return value
    },
        
    ReturnStatement(ast, env) {
        return 'return ' + visitFirst(this, ast, env)
    },

    WhileStatement(ast, env) {
        const [a,b] = visitChildren(this, ast, env)
        return `while ${a} ${b}`
    },
    IfStatement(ast, env) {
        let s = 'if '
        const children = visitChildren(this, ast, env)
        s += children[0]
        s += children[1]
        s += ' '
        if (children.length == 3) {
            s += 'else '
            s += children[2]
        }
        return s
    },

    ArrayExpression(ast, env) {
        const children = visitChildren(this, ast, env)
        return arrayString(children)

        // const maxLength = this.options.objectMaxLength
        // return objectOrArrayHandler(args, maxLength, Array)
    },
    ArrayPattern(ast, env) {
        const store = getStore(this, ast, env)
        return brackets(store, "[]")
    },
    ArrowFunction(ast, env) {
        return visitArrowFunction(this, ast, env)
        const newEnv = env.createEnv()
        const [a, b] = visitChildren(this, ast, newEnv)
        if (ast.children[1].name == "Block") {
            return `${a} => ${b}`
        } else {
            return `${a} => ${b}`
        }
    },
    AssignmentExpression(ast, env) {
        const [a, b] = visitChildren(this, ast, env)
        return `${a} = ${b}`
    },
    AwaitExpression(ast, env) {
        return "await " + visitFirst(this, ast, env)
    },
    ArithOp(ast) {
        return ast.value
    },

    CompareOp(ast) {
        return ast.value
    },
    BinaryExpression(ast, env) {
        const [a, compare, b] = visitChildren(this, ast, env)
        return `${a} ${compare} ${b}`
    },
    Block(ast, env) {
        // pause(ast)
        const children = visitChildren(this, ast, env)
        return brackets(children, "{}", "")
    },

    ClassBody(ast, env) {
        const children = visitChildren(this, ast, env)
        return brackets(children, "{}", "")
    },
    ClassDeclaration(ast, env) {
        const newEnv = env.createEnv()
        const a = this.visit(ast.children[0], env)
        if (ast.attrs?.extends) {
            const b = this.visit(ast.children[1], env)
            const c = this.visit(ast.children[2], newEnv)
            return `class ${a} extends ${b} ${c}`
        } else {
            const b = this.visit(ast.children[1], env)
            return `class ${a} ${b}`
        }
    },
    ClassExpression(ast, env) {
        return this.visitors.ClassDeclaration(ast, env)
    },
    CallExpression(ast, env) {
        const [a, b] = visitChildren(this, ast, env)
        return `${a}${b}`
    },
    ExpressionStatement(ast, env) {
        return visitFirst(this, ast, env)
    },

    ExportDeclaration(ast, env) {
        return visitFirst(this, ast, env)
    },
    ExportGroup({ children }, env) {
        const store = []
        for (let i = 0; i < children.length; i++) {
            const child = children[i]
            if (child.name == "as") {
                i += 1
            } else {
                const varName = child.value
                store.push(this.visit(child, env))
            }
        }
        return store
    },
    FunctionDeclaration(ast, env) {
        return visitFunction(this, ast, env)
    },
    ObjectExpression(ast, env) {
        const children = visitChildren(this, ast, env)
        return objectString(children)
    },

    FunctionExpression(ast, env) {
        return visitFunction(this, ast, env)
    },
    ImportDeclaration(ast, env) {
        // return new ImportDeclaration(this, ast, env)
        const [a, b, c] = ast.children
        if (a.name == "ImportGroup") {
            const importGroupString = this.visit(a, env)
            const file = b.value.slice(1, -1)
            return `import ${importGroupString} from "${file}"`
        } else {
            const name = this.visit(b, env)
            const file = c.value.slice(1, -1)
            return `import * as ${name} from "${file}"`
        }
    },
    ImportGroup({ children }, env) {
        const store = []
        for (let i = 0; i < children.length; i++) {
            const child = children[i]
            const next = children[i + 1]
            if (next?.name == "as") {
                store.push(children[i + 2])
                i += 2
            } else {
                store.push(child)
            }
        }
        const imports = store.map((x) => this.visit(x, env))
        return importGroupString(
            imports,
            this.options.maxImportLength,
        )
    },
    Interpolation(ast, env) {
        pause(ast)
        return
    },
    InterpolationStart(ast, env) {
        pause(ast)
        return
    },

    InterpolationEnd(ast, env) {
        pause(ast)
        return
    },
    BlockComment(ast, env) {
        return
    },
    LineComment(ast, env) {
        // you want to look at the position where it happened from
        // pause(ast)
        // return '// asdf'
        return ast.value
    },
    MemberExpression(ast, env) {
        return visitChildren(this, ast, env).join(".")
        // const [left, right] =
        // return
        // console.log("[left, right]", [left, right])
        // console.log("ab", ab)
        // return ab
    },
    MethodDeclaration(ast, env) {
        return visitMethod(this, ast, env)
    },
    ObjectPattern(ast, env) {
        const children = visitChildren(this, ast, env)
        return brackets(children, "{}")
    },
    ParenthesizedExpression(ast, env) {
        return `(${visitFirst(this, ast, env)})`
    },
    PatternProperty(ast, env) {
        const children = visitChildren(this, ast, env)
        return children.join(" = ")
    },
    PrivatePropertyDefinition(ast, env) {
        return
    },
    PrivatePropertyName(ast, env) {
        return
    },
    Property(ast, env) {
        const [a, b] = ast.children
        const [c, d] = visitChildren(this, ast, env)
        switch (a.name) {
            case "String":
            case "Number":
                return `"${c.slice(1, -1)}": ${d}`
            case "PropertyDefinition":
                return `"${c}": ${d}`
            default:
                return `[${c}]: ${d}`
        }
    },
    PropertyDeclaration(ast, env) {
        return
    },
    PropertyDefinition(ast, env) {
        return ast.value
    },
    PropertyName({ value }, env) {
        return value
        return
    },
    PropertyType(ast, env) {
        return
    },
    SequenceExpression(ast, env) {
        return
    },
    SingleClassItem(ast, env) {
        return
    },
    SingleExpression(ast, env) {
        return
    },
    TemplateString(ast, env) {
        pause(ast)
        return
    },
    UnaryExpression(ast, env) {
        return
    },
    VariableDeclaration(ast, env) {
        // pause(ast)
        // const a = ast.children[0].value
        // const b = this.visit(ast.children[1], env)
        // pause("pausing @ b", b)
        // env.declareVar(a, b)
        const [a, b] = visitChildren(this, ast, env)
        // const name = ast.children[0].value
        // const bast = ast.children[1]
        // pause(b, 'hi')
        // env.declareVar(name, b)

        const prefix = ast.attrs.varPrefix || ast.attrs.letPrefix
            ? "let "
            : ast.attrs.constPrefix
            ? "const "
            : ""
        return `${prefix}${a} = ${b}`
    },
    VariableDefinition({ value }, env) {
        env.declareVar(value, true)
        return value
    },
    VariableName({ value }, env) {
        env.touch(value)
        return value
    },
    NewExpression(ast, env) {
        const children = visitChildren(this, ast, env)
        return "new " + children.join("")
    },

    YieldExpression(ast, env) {
        return
    },
    RegExp(ast, env) {
        const [a, b] = match(ast.value, /^\/(.*?)\/(\w*)$/)
        return `/${a}/${b}`
    },
    ArgList(ast, env) {
        const children = visitChildren(this, ast, env)
        const value = argString(children, this.options.maxLength)
        return value
    },
    ParamList(ast, newEnv, oldEnv) {
        const store = getParamChildren(ast)
        const mapper = ([a, b]) => {
            const B = this.visit(b, oldEnv)
            const A = this.visit(a, newEnv)
            return [a, b]
        }
        const params = store.map(mapper)
        // pause(params)
        return paramString(params, this.options.maxLength)
    },
    String({ value }) {
        const s = value.slice(1, -1)
        const singleQuotes = this.options.singleQuotes
        return singleQuotes ? `'${s}'` : `"${s}"`
    },

    Number({ value }) {
        return value
    },
}
function importGroupString(imports, length) {
    const s = `{${imports.join(", ")}}`
    return s
}
function getParamChildren(ast) {
    const defs = [
        "VariableDefinition",
        "ObjectPattern",
        "ArrayPattern",
    ]

    const store = []
    const children = ast.children

    for (let i = 0; i < children.length; i++) {
        const temp = []
        const child = children[i]
        const next = children[i + 1]
        if (defs.includes(next?.name)) {
            temp.push(child)
        } else {
            temp.push(child)
            temp.push(next)
            i += 1
        }
        store.push(temp)
    }
    // pause(store)
    return store
}

function getArgChildren(ast) {
    const defs = [
        "VariableDefinition",
        "ObjectPattern",
        "ArrayPattern",
    ]

    const store = []
    const children = ast.children

    for (let i = 0; i < children.length; i++) {
        const temp = []
        const [child, next] = children.slice(i, i + 2)
        if (next == "VariableDefinition") {
            temp.push(child)
        } else {
            temp.push(child)
            temp.push(next)
            i += 1
        }
        store.push(temp)
    }
    return store
}
function getStore(self, ast, env) {
    const store = getArgChildren(ast)
    const stringer = ([a, b]) => {
        if (isDefined(b)) {
            return `${a} = ${b}`
        }
        return a
    }
    const mapper = (children) => {
        return children.map((child) => self.visit(child, env))
    }
    return store.map(mapper).map(stringer)
}
function getObjectStore(self, ast, env) {
    const store = []
    const children = ast.children

    for (let i = 0; i < children.length; i++) {
        const temp = []
        const [child, next] = children.slice(i, i + 2)
        if (next == "VariableDefinition") {
            temp.push(child)
        } else {
            temp.push(child)
            temp.push(next)
            i += 1
        }
        store.push(temp)
    }
    return store
    const stringer = ([a, b]) => {
        if (isDefined(b)) {
            return `${a} = ${b}`
        }
        return a
    }
    const mapper = (children) => {
        return children.map((child) => self.visit(child, env))
    }
    return store.map(mapper).map(stringer)
}
function visitMethod(self, ast, env) {
    const newEnv = env.createEnv()
    const asyncPrefix = ast.attrs?.asyncPrefix ? 'async ' : ''
    const a = self.visit(ast.children[0], env)         // the name
    const b = self.visit(ast.children[1], newEnv, env) // the params
    const c = self.visit(ast.children[2], newEnv)      // the body
    return `${asyncPrefix}${a}${b} ${c}`
}

function visitFunction(self, ast, env) {
    const newEnv = env.createEnv()
    const length = ast.children.length
    const asyncPrefix = ast.attrs?.asyncPrefix ? 'async ' : ''

    if (length == 3) {
        const a = self.visit(ast.children[0], env) // the name
        const b = self.visit(ast.children[1], newEnv, env) // the params
        const c = self.visit(ast.children[2], newEnv) // the body
        return `${asyncPrefix}function ${a}${b} ${c}`
    } else {
        const a = ''
        const b = self.visit(ast.children[0], newEnv) // the params
        const c = self.visit(ast.children[1], newEnv, env) // the body
        return `${asyncPrefix}function ${a}${b} ${c}`
    }
}
function visitArrowFunction(self, ast, env) {
    const newEnv = env.createEnv()
    const length = ast.children.length
    const asyncPrefix = ast.attrs?.asyncPrefix ? 'async ' : ''

    const a = ''
    const b = self.visit(ast.children[0], newEnv) // the params
    const c = self.visit(ast.children[1], newEnv, env) // the body
    return `${asyncPrefix} ${b} => ${c}`
}
function objectString(children, maxLength = 30) {
	
    const flat = `{${children.join(', ')}}`
    if (flat.length < maxLength) {
        return flat
    }
    return brackets(children, "{}")
}
function arrayString(children, maxLength = 80) {
    const flat = `[${children.join(', ')}]`
    if (flat.length < maxLength) {
        return flat
    }
    return brackets(children, '[]')
}

