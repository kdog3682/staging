import { getInputState } from "/home/kdog3682/2024-javascript/js-toolkit/browser.js"
import { datetime } from "/home/kdog3682/2024-javascript/datetime/main.js"
/* deno-fmt-ignore */ import { deepToggle,fooga, maybeNewlineIndent, onAndOff, flattenModule, isModule, isNativeHtmlTag, partitionByValues, strcall, getLongest2, must, mconfig, unreachable, notify, storager, joiner, removeVeryStartingComments, ireplace, removeCommentsInPlace, editf, getLineTokens, IndexedStore, abstractError, bool, xassert, getSetLines, inMiddle, replaceLast, ensureExtension, multipleReplacer, getGradeLevel, constructEdit, getYear, Modulus, wrapClassMethods, proseReplacer, parseComments, parseFunctionDictComments, todo, dictAssertion, boundModularIncrement, construct, reduceToString2, pageTurner, assignCumulative, defaultMergeStrategy, dictSetter3, toArguments, reTemplate, parseFrontmatter, typeAssertion, defineGetter, assignAllowed, simpleRecursiveWalk, simpleArgument, exprTemplater, stringifyIfNotPrimitive, panic, stringerf, wrapFunction, regexTemplater, iso8601, strftime, walkChildEntries, getFiletype, matchf, isUrl, looksLikeFunction, toArgument2, notNull, CumulativeStorage2, simpleAssign, findAndMatch, infuseObjectArray, regexGetter, splitArg, isJavascriptComment, runTest, everyOther, splitByRange, get_regex, getImports, isJavascriptFile, isValidDateString, WriteObject, equalityf, group2, splitOnce2, dedent4, isLowerCase, looksLikeRegExpString, isRegExpString, getDependencies, camelSplit, toggle3, countf, isLiteralObject, bindMethodsAndState2, call, mget3, looks_like_object_function, create_functions_from_master, toStringArgumentPretty, codeChunks, smart_map, run_tests, hasStartingCallable, mapTemplate, aliaser, fixSelector, htmlTags, removePythonComments, simpleStringBreaker, colonConfig, operations, error, redColon, so2, group, parseSingleLineJson, Items, findDependencies, tryf, find4, localeString, cssComment, colonConfigf, trimArray, parseCallable, bringToLifeTextFix, localBringToLife, getCaller4, getErrorStack, forEach, getBindings, getExports, matchstr, filter4, allEqual, count, isNativeFunction, repeat, eat, getIndentAndText, StopWatch, stringDictSetter, getFunctionInfo, runRef, toLines, hasCallable, getProseWords, tally, paramify, codeSplit, debugConfig, logConfig, blueColon, toStringArgument3, stringCallable, simpleBinding, dashSplit4, appendBelow, appendAbove, removeLineComments, prependIfNecessary, smartDedent4, blueSandwich, walk4, findLineIndex, parseAB, applyTransform, kebabCase, getExcerpt, sortObject, buildFunction, maybeSort, parseFunction, isTypable, frontMatter, dictEntry, insertAfterIndex, State, bindMethods, cpop, tagRE, toggle2, createFunction2, assignIncrementedIndex, ufa, assignArray, regexFromComment, createParsersFromObject, imatch, globalConsoleDebug, bindMethodsAndState, isQuestion, oxfordComma, isUpperCase, getFunctionIdentifier, filter3, match, getMatch, alternatef, reCombine, assertion2, deepEqual, hasDollar, so, deepAssign, Tally, getFunctionNames, throwError, notEqual, tryString, prettyPrintCodeSnippet, prettyPrintErrorStack, iter, quotify, transformerf, assign, defineBinding, jspy, linebreak, stringCall2, reduce3, getClassParameters, assignOnTop2, isIdentifier, ndy, dashSplit3, runFunctionFromRef, equalf, alphabet, stateGetterFromSchema, mreplace, require, topLineComment, isChinese, replacef, ignoref, codeLibrary, splitLines, addArgumentQuotes, getBindings2, addCaret, mget2, getStartingConfig, incrementalEat, strlen, hr, setOnce, unescapeHtml, oxford, breakerf, runTests, map3, dateSplit, transformDict, walk3, toRegExp, tryAgainf, assertNotNull, getArgumentObject, isArgumentObject, typef, requireArg, keyAndValue, assignf, stateGetter3, objectFromArguments2, assignDefaults, transformValue, assign3, assignFresh3, evaluate3, scopedEvaluator, objectFromArguments, enforce, sub, filterObject, extractStartingJsonLikeConfig, unbrackify, newlineIndent2, deleteLine, both, normalizeIndent, getComment, secondComment, isStringRegExp, dashSplit2, clock, warning, errorStringify, alert, labelCase, bottomComment, stringCompose, getAnyIdentifier, chalkf, getNumbers, partitions, has, addUnit, toCallable, unquote, filter2, warn2, join2, caller2, assignOnce, longShort, shortLong, argPop, caller, assignOnTop, toggle, defineWindow, unescapeNewlines, escapeQuotes, unescapeQuotes, escapeNewlines, setAliases, announceCaller, removeStartingComments, smartBind, assignExisting, isObjectWithKey, eatStart, modularIncrementItem, getRegex, runFunction, isObjectLikeArray, itemGetter2, getAllKeys, prefixSlice, hasQuotes, assertion, diff, toggleState, initState, dunder, objectGetter, superTransform, popFilter, testRunner, assert2, insertAtDollar, popEmptyLine, getOptions, mergeSpecs, sortByKeys, map2, strictMessengerAssert, smartSplit, chalk4, typeLog, getFunctionName, Clock, search3, MyError, fuzzyMatch3, debugDisplay, getCaller3, messengerAssert, camelSlice, setPrototype, assignAliases, display, modifyNumber, toDict, setPush, modularIncrementIndex, longstamp, popIndex, toggleOnOff, locWrap, walk2, typeMatch, prettyStringify, getIdentifiers, CustomError, argMatch, brackify2, smartestDedent, modularIncrementNumber, AbstractMethodError, allUnique, Trie, boundarySplit, numberBoundarySplit, nodeLog, getFirst, defineProperty, supermix, partial, timeLog, timestamp, raise, getIdentifier, conditionalPrefix, conditionalSuffix, QueryList, fuzzyMatch2, buildDict, getTextAndCommand, sprawlFactory, getParameters2, pushf, intersection, union, blue, green, sandwich, getLastSpaces, smartDedent3, red, sort, debounce, checkValue, getCodeChunks, logf, boundary, myError, conditional, isStringFunction, toSpaces, objectf, searchAll, difference, singleQuote, itemGetter, slice2, mergeObjects, once, dashSplit, nchalk, coerceToObject, ArrayState, exporter2, indent2, iterator, removeAllComments, countParams, cumulativeSchemaAssign, argKwargSplit, argParse, removeInlineComments, getFrontMatter, hasHtmlSuffix, lazyArray, isThisFunction, escapeHTML, getKwargs2, search2, toStringArgument, createFuzzyMatch, edit2, splice, zip, merge2, argArgsKwargs, fill2, chalk, vueWrap, splitArray, splitArray2, warn, makeRunner2, searchf2, smartDedent2, dedent2, toArray2, stateGetter2, sortByIndex, IndexedCache, argo, curry2, doUntil2, evaluate2, findall2, findIndex2, findItem2, getCaller2, getErrorStack2, isJson, indexGetter2, insert2, pop2, parseError2, remove2, reduce2, testf2, type2, unshift2, waterfall2, xsplit2, Cache, cumulativeAssign, replaceBefore, topComment, isAsyncFunction, mapSort, getFileURI, getQuotes, isClassObject, isInitialized, getFallback, bindingRE, addObjectOrObjectProperty, forDoubles, isCss, log, iterate, backAndForth, round, iteratorWrapper, toJSON, isFromMap, toString, empty, conditionalString, getConfigArg, hasKey, errorWrap, successWrap, check, toPoints, bind, mixinAliases, isPercentage, isBasicType, reducerStrategy, gather, entries, stateGetter, methodCase, vueCase, push2, smarterIndent, lineSplit, Store, isSingleLetter, prepareText, isSymbol, getShortest, slice, KeyError, deepCopy, argsKwargs, isError, isColor, list, objectEditor, matchall, makeFastRunner, announce, hasLetter, filter, reduce, stringCall, capitalizeName, stop, proseCase, lineDitto, mixinSetters, modularIncrement, distinct, definedSort, groupBy, reWrap2, fuzzyMatch, isPlural, Element, parseError, isPrimitiveArray, callableArgsKwargs, waterfall, defineVariable, info, flat2D, splitThePage, handleError, dedent, TypeAssertion, createFunction, pluralize, remove, Group, PageStorage, Storage, UniqueStorage, Watcher, arrayToDict, addProperty, addQuotes, argWrapFactory, assert, abrev, abf, addExtension, assignFresh, antif, atFirst, atSecond, backspace, bindObject, breaker, blockQuote, brackify, bringToLife, comment, countCaptureGroups, capitalizeTitle, classMixin, callableRE, camelToTitle, curry, createVariable, changeExtension, curryStart, curryEnd, capitalize, copy, camelCase, compose, char2n, camelToDash, deepMerge, datestamp, doublef, dictSetter, dictSetter2, dsearch, doUntil, dashCase, doubleQuote, dict, dictGetter, depluralize, dreplace, dictf, endsWithWord, exporter, edit, exists, evaluate, extend, find, flatMap, fill, fixUrl, functionGetter, findall, fixPath, flat, fparse, findIndex, firstLine, ftest, getKwargs, getFirstName, getBindingName, getParameters, getLastWord, getCodeWords, getCodeWords2, getIndent, getExtension, getLast, getLongest, getChunks, getCaller, getStackTrace, getConstructorName, getFirstWord, getWords, getSpaces, hasComma, hasSpaces, hasHtml, hasBracket, hasNewline, hasCaptureGroup, hasEquals, hasValue, hasCamelCase, hasNumber, hackReplace, insert, indexGetter, incrementf, isCallable, isQuote, isEven, isOdd, isLast, isHTML, isNode, interweave, inferLang, isString, isArray, isObject, isDefined, isFunction, isPrimitive, isNumber, isSet, isNestedArray, indent, isNull, isWord, isBoolean, isRegExp, identity, isObjectLiteral, isJsonParsable, isCapitalized, isNewLine, isObjectArray, isStringArray, isClassFunction, joinSpaces, join, keyArrayToObject, lowerCase, linebreakRE, len, lineGetter, lineCount, lastLine, logConsole, makeRunner, mixin, modularf, matchGetter, merge, mget, map, mergeOnTop, mergeToObject, mapFilter, noop, nestPush, no, newlineIndent, n2char, objectWalk, overlap, objectToString, opposite, pipe, parseTopAttrs, pascalCase, partition, parens, push, pop, parseJSON, rigidSort, removeQuotes, rep, removeComments, range, removeExtension, rescape, reverse, reWrap, reduceToString, repeatUntil, swapKey, sayhi, swap, splitMapJoin, splitCamel, smallify, search, stringify, shared, smartDedent, stringBreaker, sleep, split, snakeCase, stringArgument, sorted, splitOnce, searchf, secondLine, titleCase, textOrJson, toNumber, toArgument, toNestedArray, test, type, tail, transformObject, trim, testf, toArray, templater, totalOverlap, upperCase, unique, uncapitalize, unzip, wrap, walk, wrapf, xsplit, yes, zip2} from "/home/kdog3682/2023/utils.js"
import * as lorem from "/home/kdog3682/2023/lorem.js"

class ContextHandle {
    constructor(context, vue) {
        this.cache = new Cache()
        this.name = context.name
        const handle = context.handle || defaultHandle
        this.handle = handle.bind(this)
        this.handlers = walk(
            context.handlers,
            (v) => v.bind(vue),
        )

        const keys = [
            "onStart",
            "onEnd",
            "mounted",
        ]

        for (const key of keys) {
            const fn = c[key]
            this[key] = fn ? fn.bind(this) : noop
        }
    }
}

class HandleControl {
    constructor(vue, contexts, options = {}) {
        this.map = new Map()
        this.vue = vue
        this.options = options

        const reducer = (c) => {
            return [c.name, new ContextHandle(c, vue)]
        }
        this.contexts = reduce(contexts, reducer)
        this.setContext(this.contexts[0].name)
    }
    setContext(name, props) {
        if (this.context) {
            this.context.cache.set("input", this.vue.input)
            this.context.onEnd()
            this.prevContext = this.context
        }

        this.context = this.contexts[name]
        this.vue.input = this.context.cache.get("input") || ""
        this.context.onStart(props || {})
        this.listen(this.setListener(this.context.handle))
    }

    setListener(contextHandle) {
        if (this.map.has(contextHandle)) {
            return this.map.get(contextHandle)
        }

        const listener = (e) => {
            const inputState = getInputState(e)
            if (!inputState) {
                return
            }

            const before = this.options?.before
            const after = this.options?.after

            const vue = this.vue
            const input = vue.input

            if (before) {
                before(this)
            }

            const result = contextHandle(inputState, input)

            if (result === false) {
                return 
            } 

            if (result) {
                if (result.newContext) {
                    this.setContext(result.newContext)
                }
                else if (result.newContext) {
                    this.setContext(result.newContext)
                }
                vue.input = ''
            } else if (vue.input.length != input.length) {
                // pass
            } else if (inputState.arg.length == 1) {
                vue.input += inputState.arg
            }

            if (after) {
                after(this)
            }
        }

        this.map.set(contextHandle, listener)
        return listener
    }

    listen(listener) {
        if (this.listener == listener) {
            return
        }
        window.removeEventListener("keydown", this.listener)
        window.addEventListener("keydown", listener)
        this.listener = listener
    }
}

const defaultHandlers = {
    before() {
        console.log("h")
        console.show({ before: this.input })
    },
    after() {
        console.show({ after: this.input })
    },
    space() {
        return
    },
    numberKey(key) {
        this.input += "bbbb"
    },
    letterKey(key) {
        // return true
    },
    symbolKey(key, input) {
        // return true
    },
}

function defaultHandle0(inputState, vue) {
    const { arg, name, type } = inputState
    const input = vue.input
    const before = this.handlers.before
    const after = this.handlers.after
    const fn = this.handlers[name] || this.handlers[type + "Key"]

    const currentInput = arg.length == 1 ? input + arg : input

    if (before) {
        before(currentInput)
    }

    const result = fn && fn(key, currentInput)
    if (result === false) {
        // pass
    } else if (vue.input.length != input.length) {
        // pass
    } else if (result == null && length == 1) {
        vue.input += key
    } else if (result === true) {
        vue.input = ""
    }
    if (after) {
        after(vue.input)
    }
}

const contextHandles = {
    defaultHandlers,
}

const window = lorem.window
const vue = lorem.vue
// vue.$options = { contextHandles }
// const wc = new WindowControl(vue)
// window.keydown("Escape")
// window.keydown("3")
// window.keydown('$')
export { HandleControl }

const defaultContext = {
    name: "default",
    desc:
        "when you first enter the page, you are in the default state",
    handlers: {
        d(key, currentInput) {
            // if the input is empty
            // and the d key is pressed
            // we go to the directories context

            const input = this.vue.input
            console.log(currentInput == input + key, 'should be true...')
            if (input == '') {
                return {
                    newContext: 'directories'
                }
            }
            // otherwise we return no result
            // and the d key is added to the current vue.input
        },
        f() {
            if (empty(this.vue.input)) {
                return {
                    newContext: 'files'
                }
            }
        },
        escape() {
        },
    },
}
const fileContext = {
    name: 'files',
    handlers: {
        tab() {
            // bound to vue
            // this.fileRefKey = this.$modular('fileRefs')
            const fileInput = this.$refs.input
        },
        up() {
            this.$modularIndex('files', -1)
        },
        down() {
            this.$modularIndex('files', 1)
        }
    }
}
function defaultHandle(inputState, input) {
    const { arg, name, type } = inputState
    const fn = this.handlers[name] || this.handlers[type + "Key"]
    const currentInput = arg.length == 1 ? input + arg : input
    return fn && fn(key, currentInput)
}

const contexts = [
    defaultContext,
    fileContext,
    dirContext,
]


const globalContext = {
    escape() {
        return {
            newContext: 'default'
        }
    }
}
const options = {
    globals: globalContext,
    before(self) {
        const vue = self.vue
    },
    after(self) {
        const input = self.vue.input
    }
}
const control = new HandleControl(vue, contexts, options)
